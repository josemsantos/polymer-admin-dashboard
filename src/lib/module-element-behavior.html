<link rel="import" href="../elements/dash-remove-alert.html">
<link rel="import" href="../lib/request-connection.html">
<link rel="import" href="../lib/dash-access-control-behavior.html">

<script>
  'use strict';

  function ModuleElementBehavior(superClass) {
    return class extends DashAccessControlBehavior(superClass) {
      static get properties() {
        return {
          _formActions: {
            type: Array,
            value: []
          },
          successMessage: String,
          errorMessage: String,
          route: {
            type: Object,
          },
          key: Object,
          dialog: HTMLElement,
          module: String,
          pageType: {
            type: String,
            value: 'list'
          },
          connection: String,
          modelElement: HTMLElement,
          requestConnections: {
            type: Object,
            value: {}
          },
          accessControl: {
            type: Object,
          },
          actions: Array,
          permissions: {
            type: Array
          },
          userActions: {
            type: Array
          },
          itemsPerPage: {
            type: Number,
            value: 10
          },
          page: {
            type: Number,
            value: 1,
            notify: true
          },
          filterQuery: String,
          sortQuery: String,
          filterSortRequest: {
            type: Boolean,
            value: false
          },
          payload: {
            type: Array,
            value: [
            ]
          }
        }
      }

      static get observers() {
        return [
          '_getUserActions(permissions, accessControl, actions)',
          '_setFormActions(userActions, pageType)',
        ];
      }

      _setAllActionsForAnonymous (actions) {
        this.permissions = ['ROLE_USER'];
        let _accessControl = {};
        for (let i in actions) {
          _accessControl[actions[i]] = {
            'restrictions': ['ROLE_USER']
          };
        }
        this.accessControl = _accessControl;
      }

      _getUserActions(permissions, accessControl, actions) {
        if (permissions && accessControl && actions) {
          this.userActions = super._getAvailableActions(permissions, accessControl, actions);
        }
      }

      _setConnections () {
        for (var ns in Dash.connections) {
          let url = Dash.connections[ns].url;
          let headers = Dash.connections[ns].headers;

          this.requestConnections[ns] = new RequestConnection(url, headers);
        }
      }

      _setActionsKey (data) {
        data.forEach(item => {
          item['key'] = item[this.key];
        });
        return data;
      }

      _procedureFactory (actionName, action, identifier) {
        if (action.path) {
          return {
            action: '_goToPath',
            data: this._parsePath(action.path, identifier)
          };
        } else if (action.event) {
          return {
            action: '_firEvent',
            data: this._parseEvent(action.event, identifier)
          };
        } else {
          return {
            action: '_goToPath',
            data: '/' + this.module + '/' + actionName
          };
        }
      }

      _parseEvent (event, identifier) {
        return {
          name: event,
          data: {
            key: identifier
          }
        };
      }

      _parsePath (path, identifier) {
        path = path.replace(':module', this.module);
        path = path.replace(':key', identifier);
        return path;
      }

      _firEvent (event) {
        this.dispatchEvent(new CustomEvent(event.name, {
          bubbles: true,
          composed: true,
          detail: event.data
        }));
      }

      _goToPath (path) {
        this._firEvent({
          name: 'dash-go-to',
          data: {route: path}
        });
      }

      _alert (item) {
        if (!this.dialog) {
          this.dialog = document.createElement('dash-remove-alert');

          let message = document.createAttribute("message");
          message.value = item.message;
          this.dialog.setAttributeNode(message);

          let key = document.createAttribute("key");
          key.value = item.key;
          this.dialog.setAttributeNode(key);

          document.body.appendChild(this.dialog);

          this.dialog.addEventListener('delete-group-confirmed', function (e) {
            this._deleteConfirmed(e.detail.key);
          }.bind(this));
        } else {
          this.dialog.setAttribute('key', item.key);
          this.dialog.setAttribute('message', item.message);
        }
        this.dialog.open();
      }

      _setFormActions (userActions, pageType) {
        if (!userActions || pageType !== 'form') {
          return;
        }
        if (this.userActions) {
          let _actions = [];
          for (let action in this.userActions) {
            _actions.push({
              type: action,
              label: this.actions[action].label
            })
          };
          this._formActions = _actions;
        } else {
          this._formActions = [];
        }
      }

      _execAction (e) {
        let action = e.detail.type;
        let identifier = e.detail.key;
        let procedure = this._procedureFactory(action, this.actions[action], identifier);

        if (e.detail.payload) {
          procedure.data.data['payload'] = e.detail.payload;
        }
        this[procedure.action](procedure.data);
      }

      _sanitizePayload (fields, payload) {
        let _payload = {};
        fields.forEach((field) => {
          if (payload[field] !== undefined && payload[field] !== null) {
            _payload[field] = payload[field];
          }
        });
        return _payload;
      }

      _filter (e) {
        this.filterSortRequest = true;
        this.page = 1; //reset pagination element
        let filterQuery = '';
        let queryParam = '';
        let propertyName = '';
        for (let i=0; i<this.filters.length; i++) {
          propertyName = this.filters[i].name;
          queryParam = e.detail[propertyName] ? propertyName + '=' + e.detail[propertyName] + '&' : '';
          filterQuery += queryParam;
        }
        this.filterQuery = filterQuery;
        this.modelElement.search('', this.itemsPerPage, 1, filterQuery, this.sortQuery);
        this.filterSortRequest = false;
      }

      _sort (e) {
        this.filterSortRequest = true;
        this.page = 1; //reset pagination element
        this.sortQuery = 'sort=' + e.detail.sort.property + '&order=' + e.detail.sort.direction;
        this.modelElement.search('', this.itemsPerPage, 1, this.filterQuery, this.sortQuery);
        this.filterSortRequest = false;
      }

      _selectionChanged (e) {
        console.log("selection-changed", e.detail);
      }

      _pageChanged (e) {
        if (!this.filterSortRequest) {
          this.modelElement.search('', this.itemsPerPage, e.detail.page, this.filterQuery, this.sortQuery);
        }
      }

      _deleteConfirmed (key) {
        this.shadowRoot.querySelector(this.model).delete(key);
      }

      _updateList () {
        this.getList();
      }

      _addListEventListeners () {
        this.addEventListener('dash-list-exec', this._execAction.bind(this));
        this.addEventListener('dash-filter-request', this._filter.bind(this));
        this.addEventListener('dash-list-sort', this._sort.bind(this));
        this.addEventListener('dash-list-page-changed', this._pageChanged.bind(this));
        this.addEventListener('dash-list-selection-changed', this._selectionChanged.bind(this));
      }

      _notifyUser (e) {
        let _msg = (e.detail.message) ? e.detail.message + " updated" : e.detail.id + " deleted";
        this.successMessage = "";
        this.successMessage = _msg;
      }

      constructor () {
        super();
        this._setConnections();
      }


      ready () {
        super.ready();
        Polymer.RenderStatus.afterNextRender(this, function () {
          this.modelElement = this.shadowRoot.querySelector(this.model);
          this.modelElement.connection = this.requestConnections[this.connection];
          this.modelElement.addEventListener('model-response-changed', this.onResponseChanged.bind(this));
          if (this.pageType === 'list') {
            this.getList();
            this._addListEventListeners();
          } else if (this.pageType === 'form') {
            this.getForm();
          }
        });
      }

      getItem (list, idx) {
        for (let i in list) {
          if (list[i][this.key] == idx) {
            return list[i];
          }
        }
        return false;
      }

      onResponseChanged (e) {

      }

      getList () {
        this.modelElement.search('', this.itemsPerPage);
      }

      getForm () {

      }
    }
  }

</script>
